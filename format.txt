RW Bingo Board Binary Format

T3sl4co1l, 2025/02/19
For v0.85 Bingo Mod


Introduction
---

Design goals:

- Byte oriented for easy handling and transmission
- Heavy use of enums to compact goal names, fields, types, etc. into small numbers
- Includes metadata (version, character, perks, title, comments, board dimensions, mods, etc.)
- Variable goal / field dimensions for futureproof/flexibility
- Enums can be appended to support mod content
- Viewer expandable with mod packs (mod packs must match ID and insertion order to sync up)

v0.85 text boards compress to about 10% with general-purpose compression tools (LZ77, etc.); this format should be able to beat that pretty handily.  The resulting board size may still not be convenient enough to put into e.g. a "tweet", or chat message, but it also won't take much space on a URL shortener service, or future web app (doing basically the same thing).

The following document provides some specification of file structure, and proposal and discussion for future implementation of various features and nice-to-haves in future versions of Viewer, and Bingo Mod itself.


File Format
---

Top-level file structure:

.  +---------------- Header and Metadata ---------------------+--
.  + +--------+--- . . --+-- . . --+-------- . . . ---------+ |
.  | | Fixed  | comments | GW_S02  | free    Mods and   etc | |
.  | | Header |        Z |       Z | space   settings       | |
.  | +--------+--- . . --+-- . . --+-------- . . . ---------+ |
.  |  ^        ^          ^                  ^                |
.  |  0       21       shelter              mods              |
.  +----------------------------------------------------------+--
.  (Z = zero-terminated string terminator)                   ^
.                                                         goals-1
.
.  --+---------------------- Goals ---------------------
.    |    ---- goal 0 ----      ---- goal 1, etc. ----
.    | +------+-----+-- . . -+--- . . .
.    | | type | len |  var.  |
.    | |      |     |  data  |
.    | +------+-----+-- . . -+--- . . .
.    | ^      ^     ^        ^
.    | 0      1     2        2 + goals[0].len
.  --+--------------------------------------------------
.     ^
.   goals

The file is divided in two halves: the header and related metadata, and the list of goals.


Header
---

/* padding bytes disabled */
struct bingo_header_s {
	uint32_t magicNumber; 	//	"RwBi" = Rain World BIngo board
	uint8_t version_major;	//	Version (maj.min) of Bingo Vista or Bingo Mod the board was emitted from
	uint8_t version_minor;
	uint8_t boardWidth;   	//	Normally, width = height for a square board, but leaving open the
	uint8_t boardHeight;  	//	option for other sizes. A 255x255 board is fearsomely large, anyway..
	uint8_t character;    	//	CHARACTERS index + 1 (0: any / undefined)
	uint16_t shelter;     	//	Starting shelter (offset to string)
	uint32_t perks;       	//	Bit vector of enabled perks and burdens; see EXPEDITION_FLAGS
	uint16_t goals;       	//	Starting offset where challenges are stored
	uint16_t mods;        	//	Starting offset where mods are listed; 0 = no mods
	uint16_t reserved;    	//	Reserved for future use; set to 0
	uint8_t comments[];   	//	Variable length header contents; logging, comments, additional data, etc.
};	//	sizeof(bingo_header_s) == 21

- Within a major version, files must be backwards compatible; minor versions may add optional features that can be ignored by lower versions without loss of data.
- If the list of goals is shorter than (width * height), remainders shall be filled with dummy squares (hard-coded or user-chosen default, "free" or "never" square, randomly generated, etc.).  A warning may be emitted.
- Excess goals beyond (width * height) may be ignored, a warning emitted, and/or the board size upgraded to the next largest (rectangle or square) fitting the data, adding dummy squares to fill in gaps as needed.
- Base version Expedition offers 17 perks, burdens or bonus flags; Expeditions Enhanced mod adds 12 more.  A 32-bit vector isn't all that much, considering.  Additional values must be stored in the mod or comments sections.
- Comments is a zero-terminated string of UTF-8 characters, up to (offset - sizeof(bingo_header_s)) bytes length, terminator included.  These data can include title, user comments, logging or tagging, etc.  Data after the zero terminator is nominally ignored, but can be used intentionally to store additional metadata, mod info, etc.
- Note that offsets are zero-based, not relative or cumulative, so can potentially point into the header, or overlap; this doesn't need to be an automatic error, but is likely to yield gibberish (except perhaps if one wishes to craft a board of exceptionally small size and large cleverness?).

Limits: offsets are 16-bit, limiting the header to about 64kiB; goals list is incremental and could be more or less indefinite.  I would suggest using at least 32-bit integers to handle file navigation, and mainly out of convenience as files per se can be quite large.  I suppose header size or comment string length could be subtracted to stretch the maximum header size a couple bytes further, or just use uint_32s or more, uniformly -- but 64kiB should be enough for a *lot* of games at least, and honestly I prefer a smaller size restriction?  It's not supposed to be anything elaborate, just play the game and have fun ok? :)

`shelter` is the offset to a string, the name of the starting shelter (e.g. "GW_S02", zero terminated).  String shall be placed after comments.  If not set, a zero-length string (points to a NUL byte) or zero offset (NULL pointer) can be used; this shall be interpreted as random shelter start.

Recommended `comments` format is line (CRLF) separated, with the first two lines being title, and sub-title or name or description.  Subsequent lines can add flavor text, commentary, s..story content I guess?, or whatever; or store more variables, perhaps as `"key: value\r\n"` pairs.  Possible uses may evolve over time; I would generally suggest to keep it clean, well formatted, and human-read/writable.

Mods
---

The `mods` section is a list of mod packs and settings, in order of addition to the viewer context.  Mods are enumerated by a unique ID or hash code.  Codes shall be unique to each version of each modpack.  Modpacks shall be registered in a central repository (e.g., added to Bingovista from time to time), also for review/security purposes as they're likely to contain active code that runs in the viewer context.  On loading a board, the board viewer will iterate the list of registered modpacks, matching by hash code, then load them automatically, before parsing goal data.

Similar to goals (see below), mods are prototypically represented by an identifier byte, length, and contents:

struct bingo_mod_s {
	uint8_t type;
	uint8_t length;	//	sizeof(data)
	uint8_t data[];
};

`type` is enumerated as:

/*	value increments by 1 for each entry  */
enum MODPACK_TYPE_e {
	MODPACK_END = 0,
	MODPACK_PACK
	/* , reserved codes TBD, */
};

`MODPACK_END` is a termination sentinel, indicating the final block of the list.  `length` and `hash` of this block are not read, and can be omitted, so that the sentinel byte itself is the complete block.  Typically, the mod list will be placed before (and abutting) `goals`; this condition will also be tested: a gap between sections is acceptable, overlap is invalid.

`MODPACK_PACK` represents one modpack, with any configuration settings it needs:

struct bingo_mod_pack_s {
	uint8_t type;  	//	== MODPACK_PACK
	uint8_t length;	//	== sizeof(data)
	uint32_t hash;
	uint8_t data[];
};

The amount and meaning of `data` depends on the modpack; for file encoding purposes, it should be considered an arbitrary binary string.  Typical uses might be: flags indicating extended perks; difficulty settings, score multipliers, etc.; customized world or story state; hidden item locations; etc.  Anything that can't/shouldn't be encoded in a goal, that's relevant to global or meta state, is a good fit here.


Goals
---

A concatenated string of goal objects.

A goal has the prototype:

struct bingo_goal_s {
	uint8_t type;   	//	BINGO_GOALS index
	uint8_t flags;  	//	GOAL_FLAGS bit vector
	uint8_t length; 	//	sizeof(data)
	uint8_t data[]; 	//	defined by the goal
};

Length is technically redundant, defined by the goal.  It is provided for three reasons:
1. Convenience: while scanning a file, length doesn't need to be looked up at every stop;
2. An undefined goal type could not be scanned past, dooming all subsequent goals to a fate of data loss or corruption.
3. Simplicity: corollary to (1), variable-length goals (containing one or more [variable] strings, lists, etc.) might require deeper inspection (summing length bytes, finding zeros, etc.).  Would rather spend an extra byte than have to functionalize that.

A "hidden" flag is desirable, to implement hidden goals similar to base Expedition.  This could be inserted as its own byte (as shown), leeched off the `type` or `length` fields (e.g. take the top bit, reducing the range of the field by half -- it might not ever be needed), or implemented arbitrarily within each goal's `data`.  Dedicating a single byte to this purpose seems a simple and acceptable compromise.

As of v1.3, the status flags are still unused.  It seems unlikely that more than four bits will ever be needed; they remain reserved for future use.  The upper nibble has been made available for storing challenge flags; thus, boolean parameters are read starting from this position (offsetof(flags)).

`data` is parsed using supplementary information.  A goal definition specifies how many, and what type of, parameters it's composed of.  Strings from base game and Bingo Mod are provided for rich use of enums, minimizing encode size.

Goals utilize four data types: Boolean, Integer, String, and List.  The first three generally come from a SettingBox instance, where a Boolean can be selected on a checkbox, or an Integer with a number box, or a String value from a droplist of accepted strings.  (We implement the string lists here with an enum.)  Integers (and Booleans coerced to Integers) also occasionally appear in the text format, "naked"; they are used for internal values like partial completion flags, or progression amounts before the completion total has been achieved.  Free (variable-length or zero-terminated) Strings, and Lists, are used for variable-length data: typically, data that aren't otherwise enumerable (e.g. room names), or that record a list of partially completed goals that can't be expressed by a simple number.

Observationally, Integers range from 0...500 (except for BingoVistaChallenge which stores room coordinates), and strings are short (10s of characters).  I suppose room names (if not stored in enums) could be arbitrary length, but it seems unlikely anyone should need more than 250 or so characters.

A goal might look like so:

struct goal_steal_s {
	uint8_t type;   	//	== BINGO_GOAL_STEAL
	uint8_t flags;  	//	bits 0-3 reserved; bit 4: true = from Scavenger toll, false = from Scavengers
	uint8_t length; 	//	== sizeof(uint8_t) + sizeof(uint16_t) == 3
	uint8_t theft;  	//	index to STEALABLESTOABLE ("theft") enum
	uint16_t amount;	//	number of items to steal
};	//	sizeof(goal_steal_s) == 6

Compare to the text format (split by "><"'s): ["System.String|Rock|Item|1|theft", "System.Boolean|false|From Scavenger Toll|0|NULL", "0", "System.Int32|3|Amount|2|NULL", "0", "0"].  The corresponding goal descriptor contains:

{
	name: "BingoStealChallenge",
	params: [
		{ type: "number", offset: 0, size: 1, formatter: "theft"   },	//	0: Item choice
		{ type: "bool",   offset: 0,  bit: 4, formatter: "boolean" },	//	1: From Toll flag
		{ type: "number", offset: 1, size: 2, formatter: ""        } 	//	2: Steal amount
	],
	desc: "System.String|{0}|Item|1|theft><System.Boolean|{1}|From Scavenger Toll|0|NULL><0><System.Int32|{2}|Amount|2|NULL><0><0"
}

`params` is the list of parameters.  The ordering is used by `desc`, into which the values are substituted.  Thus the "{0}" might get replaced with "Rock", and so on.  `type` describes how the field is filled: one bit, one byte or word (numerically), or a string/array.  `formatter` is the enum or conversion table to apply to the value (or each in a string/array of values).  `offset` is the starting offset within `data` (for `bool`: `data` - 2) from which to read the parameter.  `bit` is the bit position to check (`bool` only).  `size` is the number of bytes to read as a number.  Other parameters and details are documented in the comments on `BINARY_TO_STRING_DEFINITIONS`.

Enums are provided "pre-installed" in the viewer (and, obviously, in the game itself), and include all sets of in-game items, creatures, regions, and Expedition and Bingo goal targets.  The names of these lists are given in the Enums section.  Mod packs can add their own global enums, and append to existing global enums; indices beyond pre-installed ranges therefore depend on which mods are loaded, and in what order.  Mod packs can also add to the list of parsers, or replace existing parsers.

Another example:

struct goal_vista_s {
	uint16_t x;
	uint16_t y;
	uint8_t room[];	//	example, "CC_A10"
};

Text format example: ["CC", "System.String|CC_A10|Room|0|vista", "734", "506", "0", "0"]

Vistas are peculiar, and are worth some discussion.  They also present a conundrum for gameplay purposes.

As room coordinates are stored in the goal, Vistas are uniquely customizable in the goal text.  This quality seems worth preserving; therefore, rather than preparing an enum list of tokens, or even rooms or regions, the full room name is stored.  This could take up some dozens of bytes, making it one of the longer (worst-case length) goals; but room and region names are likely to remain small, so this seems an acceptable compromise.  (Later (in v0.90), an alternate encoding was added, using an enum of stock Vista locations.  The general version remains as a fallback.)

Region code shall be separated from the string by reading until the first underscore; all official examples follow this pattern, existing mods (generally?) do, and future mods are likely to continue to do so.  (Perhaps this is actually required, by other code I don't know about; or is customary in available tools.)

Note that base Expedition provides three vistas per region, and no hint of which was chosen at goal generation time; if this behavior is desired, any generator, editor or viewer must suppress location and room code to avoid spoiling the goal.  These data are always present in the board data, and a sufficiently dedicated player can always access it; this is not a solvable problem on the formatting side, unfortunately.

A more reliable method to avoid spoilers, would be adding an alternative goal type, which includes region index only, then selecting the room or token at game start (including syncing that choice between connected players in multiplayer games).  This reduces the amount of time available for an intrepid player to analyze the goal (i.e., it might "leak" into the game log files), and most likely requires tools to do so (e.g. remote board viewing mod, or if nothing else, memory viewer / debugger attached to the game, or packet analyzer viewing communications).


Enums
---

Some of the enums used by the viewer are listed below, for illustration.  (Please refer to bingovista.js for complete listings.)  For simplicity, these have been split up and expressed in likely C syntax.

---

Header `character` takes the following value:

enum CHARACTERS_e {
	CHAR_MONK = 0,
	CHAR_SURVIVOR,
	CHAR_HUNTER,
	CHAR_GOURMAND,
	CHAR_ARTIFICER,
	CHAR_RIVULET,
	CHAR_SPEARMASTER,
	CHAR_SAINT,
	CHAR_INV,
	CHAR_NIGHT,
	CHAR_WATCHER
	/* , additional mod-defined characters, */
};

(Trivia: Nightcat actually went unused; turns out, Watcher is their own thing internally.  Probably because some mods have implemented Nightcat, and a new one avoids breaking them?)

This value indexes the following arrays:

/*	internal enum names  */
const char* const CHARACTER_KEYS[] = {
	/*	from base game, SlugcatStats::SlugcatFoodMeter and SlugcatStats.Name  */
	"Yellow",
	"White",
	"Red",
	"Gourmand",
	"Artificer",
	"Rivulet",
	"Spear",
	"Saint",
	"Sofanthiel",
	"Night",
	"Watcher"
};

/*	character display text names (English)  */
const char* const CHARACTER_VALUES[] = {
	/*	SlugcatStats::getSlugcatName  */
	"Monk",
	"Survivor",
	"Hunter",
	"Gourmand",
	"Artificer",
	"Rivulet",
	"Spearmaster",
	"Saint",
	"Sofanthiel",
	"Nightcat",
	"Watcher"
};

---

Header `perks` is a bit array taking any sum of these values:

enum EXPEDITION_FLAGS_e {	/*	min size: uint32_t  */
	/*	In no particular order; compiled from https://rainworld.miraheze.org/wiki/Expedition#Perks on 2025/02/07 */
	EXPFLAG_LANTERN    = 0x00000001,
	EXPFLAG_MASK       = 0x00000002,
	EXPFLAG_BOMB       = 0x00000004,
	EXPFLAG_NEURON     = 0x00000008,
	EXPFLAG_BACKSPEAR  = 0x00000010,
	EXPFLAG_FLOWER     = 0x00000020,
	EXPFLAG_PASSAGE    = 0x00000040,
	EXPFLAG_SLOWTIME   = 0x00000080,
	EXPFLAG_SINGUBOMB  = 0x00000100,
	EXPFLAG_ELECSPEAR  = 0x00000200,
	EXPFLAG_DUALWIELD  = 0x00000400,
	EXPFLAG_EXPRESIST  = 0x00000800,
	EXPFLAG_EXPJUMP    = 0x00001000,
	EXPFLAG_CRAFTING   = 0x00002000,
	EXPFLAG_AGILITY    = 0x00004000,
	EXPFLAG_RIFLE      = 0x00008000,
	EXPFLAG_BLINDED    = 0x00010000,
	EXPFLAG_DOOMED     = 0x00020000,
	EXPFLAG_HUNTED     = 0x00040000,
	EXPFLAG_PURSUED    = 0x00080000,
	EXPFLAG_AURA       = 0x00100000,
	EXPFLAG_LOCKOUT    = 0x00200000,	//	lockout and blackout flags added v0.90
	EXPFLAG_BLACKOUT   = 0x00400000,
	EXPFLAG_RESERVED23 = 0x00800000,
	EXPFLAG_RESERVED24 = 0x01000000,
	EXPFLAG_RESERVED25 = 0x02000000,
	EXPFLAG_RESERVED26 = 0x04000000,
	EXPFLAG_RESERVED27 = 0x08000000,
	EXPFLAG_RESERVED28 = 0x10000000,
	EXPFLAG_RESERVED29 = 0x20000000,
	EXPFLAG_RESERVED30 = 0x40000000,
	EXPFLAG_RESERVED31 = 0x80000000
};

The corresponding display names are listed below; indices are in enumerated order, or as given by `floor(log2(flag)))`.  The corresponding function should be self-explanatory.

const char* const EXPFLAG_NAMES[] = {
	"Perk: Scavenger Lantern",
	"Perk: Vulture Mask",
	"Perk: Scavenger Bomb",
	"Perk: Neuron Glow",
	"Perk: Back Spear",
	"Perk: Karma Flower",
	"Perk: Enable Passages",
	"Perk: Slow Time",
	"Perk: Singularity Bomb",
	"Perk: Electric Spear",
	"Perk: Spear Dual-Wielding",
	"Perk: Explosion Resistance",
	"Perk: Explosive Jump",
	"Perk: Item Crafting",
	"Perk: High Agility",
	"Perk: Joke Rifle",
	"Burden: Blinded",
	"Burden: Doomed",
	"Burden: Hunted",
	"Burden: Pursued",
	"Aura",
	"Gameplay: Lockout",
	"Gameplay: Blackout",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
};

As of v1.3, these are not used by the mod, and can be considered optional; they can be viewed as recommended play settings for the board.  A future version of the mod may choose to implement these, in various ways (as initial values for user choice, fixed as in pre-baked Expedition missions, etc.).

In a given version that does not define bits beyond these, they can be used by mods, or ignored (placing additional flags in the mod-specific section).  Making no particular recommendations at this time.  Maybe it'll be easier to configure things separately?  Then again, having everything in one list (and using big enough integers to hold onto all flags at once?) probably simplifies modding and readout.  TBD.

---

Bingo goal `type`:

Goals defined by Expedition and Bingo as of Bingo v0.85.  Indexed by `struct bingo_goal_s::type`.  Values:

enum BINGO_GOALS_e {
​	BINGO_GOAL_CHALLENGE = 0,	//	Default, unused or unimplemented item
	BINGO_GOAL_ACHIEVEMENT,
​	BINGO_GOAL_ALLREGIONSEXCEPT,
​	BINGO_GOAL_BOMBTOLL,
​	BINGO_GOAL_COLLECTPEARL,
​	BINGO_GOAL_CRAFT,
​	BINGO_GOAL_CREATUREGATE,
​	BINGO_GOAL_CYCLESCORE,
​	BINGO_GOAL_DAMAGE,
​	BINGO_GOAL_DEPTHS,
​	BINGO_GOAL_DODGELEVIATHAN,
​	BINGO_GOAL_DONTUSEITEM,
​	BINGO_GOAL_EAT,
​	BINGO_GOAL_ECHO,
​	BINGO_GOAL_ENTERREGION,
​	BINGO_GOAL_GLOBALSCORE,
​	BINGO_GOAL_GREENNEURON,
​	BINGO_GOAL_HATCHNOODLE,
​	BINGO_GOAL_HELL,
​	BINGO_GOAL_ITEMHOARD,
​	BINGO_GOAL_KARMAFLOWER,
​	BINGO_GOAL_KILL,
​	BINGO_GOAL_MAULTYPES,
​	BINGO_GOAL_MAULX,
​	BINGO_GOAL_NEURONDELIVERY,
​	BINGO_GOAL_NONEEDLETRADING,
​	BINGO_GOAL_NOREGION,
​	BINGO_GOAL_PEARLDELIVERY,
​	BINGO_GOAL_PEARLHOARD,
​	BINGO_GOAL_PIN,
​	BINGO_GOAL_POPCORN,
​	BINGO_GOAL_RIVCELL,
​	BINGO_GOAL_SAINTDELIVERY,
​	BINGO_GOAL_SAINTPOPCORN,
​	BINGO_GOAL_STEAL,
​	BINGO_GOAL_TAME,
​	BINGO_GOAL_TRADE,
​	BINGO_GOAL_TRADETRADED,
​	BINGO_GOAL_TRANSPORT,
​	BINGO_GOAL_UNLOCK,
​	BINGO_GOAL_VISTA,
	BINGO_GOAL_VISTAEX,
	BINGO_GOAL_ENTERREGIONFROM,
	BINGO_GOAL_MOONCLOAK,
	BINGO_GOAL_BROADCAST,
	BINGO_GOAL_DAMAGEEX,
	BINGO_GOAL_TAMEEX,
	BINGO_GOAL_BOMBTOLLEX,
	BINGO_GOAL_ECHOEX,
	BINGO_GOAL_DODGENOOT,
	BINGO_GOAL_DONTKILL,
	BINGO_GOAL_GOURMANDCRUSH,
	BINGO_GOAL_ITERATOR,
	BINGO_GOAL_ITEMHOARDEX,
	BINGO_GOAL_LICK
};

/*	internal enum names  */
const char* const BINGOGOAL_KEYS[] = {
​	"BingoChallenge",
	"BingoAchievementChallenge",
​	"BingoAllRegionsExcept",
​	"BingoBombTollChallenge",
​	"BingoCollectPearlChallenge",
​	"BingoCraftChallenge",
​	"BingoCreatureGateChallenge",
​	"BingoCycleScoreChallenge",
​	"BingoDamageChallenge",
​	"BingoDepthsChallenge",
​	"BingoDodgeLeviathanChallenge",
​	"BingoDontUseItemChallenge",
​	"BingoEatChallenge",
​	"BingoEchoChallenge",
​	"BingoEnterRegionChallenge",
​	"BingoGlobalScoreChallenge",
​	"BingoGreenNeuronChallenge",
​	"BingoHatchNoodleChallenge",
​	"BingoHellChallenge",
​	"BingoItemHoardChallenge",
​	"BingoKarmaFlowerChallenge",
​	"BingoKillChallenge",
​	"BingoMaulTypesChallenge",
​	"BingoMaulXChallenge",
​	"BingoNeuronDeliveryChallenge",
​	"BingoNoNeedleTradingChallenge",
​	"BingoNoRegionChallenge",
​	"BingoPearlDeliveryChallenge",
​	"BingoPearlHoardChallenge",
​	"BingoPinChallenge",
​	"BingoPopcornChallenge",
​	"BingoRivCellChallenge",
​	"BingoSaintDeliveryChallenge",
​	"BingoSaintPopcornChallenge",
​	"BingoStealChallenge",
​	"BingoTameChallenge",
​	"BingoTradeChallenge",
​	"BingoTradeTradedChallenge",
​	"BingoTransportChallenge",
​	"BingoUnlockChallenge",
​	"BingoVistaChallenge"
	"BingoVistaExChallenge",
	"BingoEnterRegionFromChallenge",
	"BingoMoonCloakChallenge",
	"BingoBroadcastChallenge",
	"BingoDamageExChallenge",
	"BingoTameExChallenge",
	"BingoBombTollExChallenge",
	"BingoEchoExChallenge",
	"BingoDodgeNootChallenge",
	"BingoDontKillChallenge",
	"BingoGourmandCrushChallenge",
	"BingoIteratorChallenge",
	"BingoItemHoardExChallenge",
	"BingoLickChallenge"
};

/*	Challenge display text names / titles (English)  */
const char* const BINGOGOAL_NAMES[] = {
​	"Empty challenge class",
	"Obtaining Passages",
	"Entering regions while never visiting one",
	"Collecting pearls",
	"Crafting items",
	"Transporting the same creature through gates",
	"Scoring cycle points",
	"Dropping a creature in the depth pit",
	"Dodging a Leviathan",
	"Avoiding items",
	"Eating specific food",
	"Entering a region",
	"Scoring global points",
	"Delivering the Green Neuron",
	"Hatching noodlefly eggs",
	"Not dying before completing challenges",
	"Consuming Karma Flowers",
	"Killing creatures",
	"Mauling different types of creatures",
	"Mauling creatures a certain amount of times",
	"Gifting neurons",
	"Avoiding gifting Needles to Scavengers",
	"Avoiding a region",
	"Delivering colored pearls to an Iterator",
	"Putting pearls in shelters",
	"Pinning creatures to walls",
	"Popping popcorn plants",
	"Feeding the Rarefaction Cell to a Leviathan",
	"Delivering the music pearl to Five Pebbles",
	"Eating popcorn plant seeds",
	"Stealing items",
	"Befriending creatures",
	"Trading items to Merchants",
	"Trading already traded items",
	"Transporting creatures",
	"Getting Arena Unlocks",
	"Visiting Vistas",
	"Entering a region from another region",
	"Moon's Cloak",
	"Getting Chat Logs",
	"Hitting creatures with items",
	"Befriending creatures",
	"Throwing grenades at Scavenger tolls",
	"Visiting echoes",
	"Dodging Noodlefly attacks",
	"Avoiding killing creatures",
	"Crushing creatures",
	"Visiting Iterators",
	"Hoarding items in shelters",
	"Getting licked by lizards"
};

---

Bingo goal `flags`:

A bit vector of flags relevant to the goal.  At this time, only one flag is defined:

enum GOAL_FLAGS_e {	/*	min size: uint8_t  */
	GOALFLAG_HIDDEN    = 0x01,
	GOALFLAG_RESERVED1 = 0x02,
	GOALFLAG_RESERVED2 = 0x04,
	GOALFLAG_RESERVED3 = 0x08,
};

Reserved flags are kept for future use; avoid placing challenge flags here.  The remaining upper nibble is free to use.

The hidden flag functions as it does in Expedition.  What's necessary to reveal goals is up to implementation. (Possible example: complete a goal: reveals adjacent hidden goals; or, complete all other goals in a row/col/diag: reveal hidden goals in same row/col/diag.)

---

An authoritative list of enums and their contents can be found in the bingovista.js `ALL_ENUMS` object.
